// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "shader.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
StructuredBuffer<Plane> _Planes;
StructuredBuffer<Box> _Boxes;
StructuredBuffer<Sphere> _Spheres;
StructuredBuffer<Disc> _Discs;
StructuredBuffer<Quad> _Quads;
StructuredBuffer<int> _Sizes;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection; 
int _Seed;
float2 _PixelOffset;

static const int MAX_DEPTH = 8;
static const int SAMPLES = 1;
static State states[MAX_DEPTH];


static float helper = 1; 
float rnd()
{
	_Seed = int(fmod(float(_Seed)*1364.0+626.0 * helper, 509.0));
	return float(_Seed)/509.0;
}

float3 UniformHemisphere(in float3 normal) 
{
    float3 x, z; 
    CreateCoordinateSystem(normal, x, z);
    float2 r = float2(rnd(), rnd());
    float2 a = float2(sqrt(1 - r.x * r.x), 2 * PI * r.y);
    
    float3 output = float3(a.x * cos(a.y), r.x, a.x * sin(a.y));
    output = float3(
        output.x * z.x + output.y * normal.x + output.z * x.x, 
        output.x * z.y + output.y * normal.y + output.z * x.y, 
        output.x * z.z + output.y * normal.z + output.z * x.z
    );
    
    return normalize(output);  
}

float3 CosineHemisphere(in float3 normal) 
{
    float3 x, z; 
    CreateCoordinateSystem(normal, x, z);
    float2 r = float2(rnd(), rnd());
    float2 a = float2(sqrt(r.x), 2 * PI * r.y);
    
    float3 output = float3(a.x * cos(a.y), sqrt(1 - r.x), a.x * sin(a.y));
    output = float3(
        output.x * z.x + output.y * normal.x + output.z * x.x, 
        output.x * z.y + output.y * normal.y + output.z * x.y, 
        output.x * z.z + output.y * normal.z + output.z * x.z
    );
    
    return normalize(output);  
}

#define PLANE 0
#define BOX 1
#define SPHERE 2
#define DISC 3
#define QUAD 4

bool FindHit(inout State state)
{   
    state.hit.dist = 100000.0f;
    bool isHit = false;

    int n = _Sizes[PLANE];
    for (int k = 0; k < n; ++k) 
    {
        isHit = isHit || PlaneHit(_Planes[k], state.ray, state.hit);
    }
    
    n = _Sizes[BOX];
    for (int l = 0; l < n; ++l) 
    {
        isHit = isHit || BoxHit(_Boxes[l], state.ray, state.hit);
    }
    
    n = _Sizes[SPHERE];
    for (int i = 0; i < n; ++i) 
    {
        isHit = isHit || SphereHit(_Spheres[i], state.ray, state.hit);
    }
    n = _Sizes[DISC];
    for (int j = 0; j < n; ++j) 
    {
        isHit = isHit || DiscHit(_Discs[j], state.ray, state.hit);
    }
    n = _Sizes[QUAD];
    for (int m = 0; m < n; ++m) 
    {
        isHit = isHit || QuadHit(_Quads[m], state.ray, state.hit);
    }
    
    state.kr_d_out.z = dot(state.ray.dir, state.hit.p_n_o[1]) < 0;
	return isHit;
}

void Push(inout int ptr, in State current) 
{
    if (ptr >= MAX_DEPTH - 1) return;
    states[ptr++] = current;
}

void Pop(inout int ptr, out State current) 
{
    current = states[--ptr];
}

float GeoAtt(in State current, in float cosi, in float coso) {
    float3 h =  normalize(current.hit.p_n_o[2] + current.ray.dir);
    float2 val;
    val.x = 2 * dot(current.hit.p_n_o[1], h) * cosi / dot(current.hit.p_n_o[2], h);
    val.y = 2 * dot(current.hit.p_n_o[1], h) * coso / dot(current.hit.p_n_o[2], h);
    
    return min(1, min(val.x, val.y));
}

float Beckmann(in State current) {
    float m = 0.18f;
    if (m < EPSILON) return 0; 
    float3 h =  normalize(current.hit.p_n_o[2] + current.ray.dir);
    float cosa = dot(current.hit.p_n_o[1], h);
    return exp( (cosa*cosa - 1)/(cosa*cosa*m*m))/(PI*m*m*pow(cosa,4));
}

float Fresnel(in State state, in float cosi) 
{
	float etai = 1.0f;
	float etat = 1.667f;
	float r0 = pow((etai - etat)/(etai + etat), 2);
	return r0 + (1 - r0) * pow((1 - abs(cosi)), 5);
}

float CookTorrance(in State state, in float cosi, in float coso)
{
    return Fresnel(state, cosi) * Beckmann(state) * GeoAtt(state, cosi, coso) / (4 * cosi * coso);
}

void Trace(inout int ptr, inout float3 color, inout State current) 
{
    bool hit = FindHit(current);
    if (current.kr_d_out[1] >= MAX_DEPTH || !hit) 
    {
        if (!hit) 
        {
            color = Black();
            current.kr_d_out[1] = MAX_DEPTH;
        }
        else if (ptr > 0) 
        {   
            Pop(ptr, current);
            float coso = dot(current.hit.p_n_o[2], current.hit.p_n_o[1]);
            float cosi = dot(current.ray.dir, current.hit.p_n_o[1]);
            color = current.hit.mat.eps + (current.hit.mat.rho + CookTorrance(current, cosi, coso) * PI) * color;
            current.kr_d_out[1] = MAX_DEPTH;
        }
        return;
    }
    current.ray.origin = current.hit.p_n_o[0] + current.hit.p_n_o[1] * EPSILON;
    current.hit.p_n_o[2] = -current.ray.dir;
    current.ray.dir = CosineHemisphere(current.hit.p_n_o[1]);
    Push(ptr, current);
    ++current.kr_d_out[1];
}


State Init(in float2 uv) 
{
    State state;
    state.ray = CreateCameraRay(_CameraToWorld, _CameraInverseProjection, uv);
    state.hit = CreateRayHit();
    state.kr_d_out[0] = 1;
    state.kr_d_out[1] = 0;
    state.kr_d_out[2] = 1;
    return state;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    _Seed = _Seed | id.x;
    _Seed = _Seed | id.y;
    _Seed = _Seed & 0x7FFFFFFF;
    float2 uv = float2((id.xy + _PixelOffset) / float2(width, height) * 2.0f - 1.0f);
    helper = length(uv);
    float2 noise = frac(sin(dot(uv + float2(rnd(),rnd())*length(uv),float2(30*rnd(),160*rnd()))) * 43758.5453);
    helper = length(noise);
    
    float3 pixel = Black();
    
    uint count = 2u << (MAX_DEPTH - 1);
    for (int i = 0; i < SAMPLES; ++i) {
        int ptr = 0;
        State current = Init(uv);
        float3 color = Black();
        for (uint j = 0; j < count; ++j) 
        {
            Trace(ptr, color, current);
        }
        pixel += color;
    }
    
    Result[id.xy] = float4(pixel / SAMPLES, 1);
    
}
