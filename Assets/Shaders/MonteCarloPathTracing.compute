// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "shader.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
StructuredBuffer<Plane> planes;
StructuredBuffer<Sphere> spheres;
StructuredBuffer<Box> boxes;
StructuredBuffer<Disc> discs;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection; 
static const int MAX_DEPTH = 5;
static const int SAMPLES = 2;
static State states[MAX_DEPTH - 1];

bool FindHit(inout State state)
{   
    uint n, stride;
    state.hit.dist_type[0] = 100000.0f;
    spheres.GetDimensions(n, stride);
    for (uint i = 0; i < n; ++i) 
    {
        SphereHit(spheres[i], state.ray, state.hit);
    }
    discs.GetDimensions(n, stride);
    for (uint j = 0; j < n; ++j) 
    {
        DiscHit(discs[j], state.ray, state.hit);
    }
    planes.GetDimensions(n, stride);
    for (uint k = 0; k < n; ++k) 
    {
        PlaneHit(planes[k], state.ray, state.hit);
    }
    boxes.GetDimensions(n, stride);
    for (uint l = 0; l < n; ++l) 
    {
        BoxHit(boxes[l], state.ray, state.hit);
    }
    
    state.kr_d_out.z = dot(state.ray.dir, state.hit.n) < 0;
	return state.hit.dist_type[0] < 100000.0f;
}

void Push(inout int ptr, in State current) 
{
    if (ptr >= MAX_DEPTH - 1) return;
    states[ptr++] = current;
}

void Pop(inout int ptr, out State current) 
{
    if (!ptr) return;
    current = states[--ptr];
}

void Trace(inout int ptr, inout float3 color, inout State current) 
{
    bool hit = FindHit(current);
    if (current.kr_d_out[1] >= MAX_DEPTH || !hit) 
    {
        if (!hit) 
        {
            color = Black();
            current.kr_d_out[1] = MAX_DEPTH;
        }
        else if (ptr > 0) 
        {   
            float d = current.hit.dist_type[0];
            Pop(ptr, current);
            float cosi = dot(current.ray.dir, current.hit.n);
            color = current.hit.mat.eps + 2 * cosi * current.hit.mat.rho * color;
            current.kr_d_out[1] = MAX_DEPTH;
        }
        return;
    }
    current.ray.origin = current.hit.pos + current.hit.n * EPSILON;
    current.ray.dir = CosineHemisphere(current.hit.n);
    Push(ptr, current);
    ++current.kr_d_out[1];
}


State Init(in float2 uv) 
{
    State state;
    state.ray = CreateCameraRay(_CameraToWorld, _CameraInverseProjection, uv);
    state.hit = CreateRayHit();
    state.kr_d_out[0] = 1;
    state.kr_d_out[1] = 0;
    state.kr_d_out[2] = 1;
    
    return state;
}

float2 _pixelOffset;
[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    float2 uv = float2((id.xy + _pixelOffset) / float2(width, height) * 2.0f - 1.0f);
    float2 noise = frac(sin(dot(uv + float2(rnd(),rnd())*length(uv),float2(30*rnd(),160*rnd()))) * 43758.5453);
    helper = length(noise);
    
    float3 pixel = Black();
    State current = Init(uv);
    uint count = 2u << (MAX_DEPTH - 1);
    for (int i = 0; i < SAMPLES; ++i) {
        int ptr = 0;
        State current = Init(uv);
        float3 color = Black();
        for (uint j = 0; j < count; ++j) 
        {
            Trace(ptr, color, current);
        }
        pixel += color;
    }
    
    
    Result[id.xy] = float4(pixel / SAMPLES, 1);
    
}
