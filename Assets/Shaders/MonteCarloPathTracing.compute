// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "shader.hlsl"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
StructuredBuffer<Plane> _Planes;
StructuredBuffer<Box> _Boxes;
StructuredBuffer<Sphere> _Spheres;
StructuredBuffer<Disc> _Discs;
StructuredBuffer<Quad> _Quads;
StructuredBuffer<int> sizes;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection; 
int _Seed;
float2 _PixelOffset;

static const int MAX_DEPTH = 5;
static const int SAMPLES = 2;
static State states[MAX_DEPTH - 1];


static float helper = 1; 
float rnd()
{
	_Seed = int(fmod(float(_Seed)*1364.0+626.0 * helper, 509.0));
	return float(_Seed)/509.0;
}

float3 UniformHemisphere(in float3 normal) 
{
    float3 x, z; 
    CreateCoordinateSystem(normal, x, z);
    float2 r = float2(rnd(), rnd());
    float2 a = float2(sqrt(1 - r.x * r.x), 2 * PI * r.y);
    
    float3 output = float3(a.x * cos(a.y), r.x, a.x * sin(a.y));
    output = float3(
        output.x * z.x + output.y * normal.x + output.z * x.x, 
        output.x * z.y + output.y * normal.y + output.z * x.y, 
        output.x * z.z + output.y * normal.z + output.z * x.z
    );
    
    return normalize(output);  
}

float3 CosineHemisphere(in float3 normal) 
{
    float3 x, z; 
    CreateCoordinateSystem(normal, x, z);
    float2 r = float2(rnd(), rnd());
    float2 a = float2(sqrt(r.x), 2 * PI * r.y);
    
    float3 output = float3(a.x * cos(a.y), sqrt(1 - r.x), a.x * sin(a.y));
    output = float3(
        output.x * z.x + output.y * normal.x + output.z * x.x, 
        output.x * z.y + output.y * normal.y + output.z * x.y, 
        output.x * z.z + output.y * normal.z + output.z * x.z
    );
    
    return normalize(output);  
}

bool FindHit(inout State state)
{   
    state.hit.dist = 100000.0f;
    int n = sizes[PLANE];
    for (int k = 0; k < n; ++k) 
    {
        PlaneHit(_Planes[k], state.ray, state.hit);
    }
    n = sizes[BOX];
    for (int l = 0; l < n; ++l) 
    {
        BoxHit(_Boxes[l], state.ray, state.hit);
    }
    n = sizes[SPHERE];
    for (int i = 0; i < n; ++i) 
    {
        SphereHit(_Spheres[i], state.ray, state.hit);
    }
    n = sizes[DISC];
    for (int j = 0; j < n; ++j) 
    {
        DiscHit(_Discs[j], state.ray, state.hit);
    }
    n = sizes[QUAD];
    for (int m = 0; m < n; ++m) 
    {
        QuadHit(_Quads[m], state.ray, state.hit);
    }
    
    state.kr_d_out.z = dot(state.ray.dir, state.hit.n) < 0;
	return state.hit.dist < 100000.0f;
}

void Push(inout int ptr, in State current) 
{
    if (ptr >= MAX_DEPTH - 1) return;
    states[ptr++] = current;
}

void Pop(inout int ptr, out State current) 
{
    if (!ptr) return;
    current = states[--ptr];
}

void Trace(inout int ptr, inout float3 color, inout State current) 
{
    bool hit = FindHit(current);
    if (current.kr_d_out[1] >= MAX_DEPTH || !hit) 
    {
        if (!hit) 
        {
            color = Black();
            current.kr_d_out[1] = MAX_DEPTH;
        }
        else if (ptr > 0) 
        {   
            Pop(ptr, current);
            float cosi = dot(current.ray.dir, current.hit.n);
            color = current.hit.mat.eps + 2 * cosi * current.hit.mat.rho * color;
            current.kr_d_out[1] = MAX_DEPTH;
        }
        return;
    }
    current.ray.origin = current.hit.pos + current.hit.n * EPSILON;
    current.ray.dir = CosineHemisphere(current.hit.n);
    Push(ptr, current);
    ++current.kr_d_out[1];
}


State Init(in float2 uv) 
{
    State state;
    state.ray = CreateCameraRay(_CameraToWorld, _CameraInverseProjection, uv);
    state.hit = CreateRayHit();
    state.kr_d_out[0] = 1;
    state.kr_d_out[1] = 0;
    state.kr_d_out[2] = 1;
    
    return state;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    uint width, height;
    Result.GetDimensions(width, height);
    _Seed = _Seed | id.x;
    _Seed = _Seed | id.y;
    _Seed = _Seed & 0x7FFFFFFF;
    float2 uv = float2((id.xy + _PixelOffset) / float2(width, height) * 2.0f - 1.0f);
    helper = length(uv);
    float2 noise = frac(sin(dot(uv + float2(rnd(),rnd())*length(uv),float2(30*rnd(),160*rnd()))) * 43758.5453);
    helper = length(noise);
    
    float3 pixel = Black();
    State current = Init(uv);
    uint count = 2u << (MAX_DEPTH - 1);
    for (int i = 0; i < SAMPLES; ++i) {
        int ptr = 0;
        State current = Init(uv);
        float3 color = Black();
        for (uint j = 0; j < count; ++j) 
        {
            Trace(ptr, color, current);
        }
        pixel += color;
    }
    
    
    Result[id.xy] = float4(pixel / SAMPLES, 1);
    
}
