

#pragma max_recursion_depth 8

#include "Utils.hlsl"

RayDesc NewCameraRay(uint2 id, uint2 dim)
{
    float2 coord = (float2(id) / dim) * 2.f - 1.f;
    RayDesc ray;
    ray.Origin = mul(_cameraToWorld, float4(0, 0, 0, 1)).xyz;
    ray.Direction = mul(_inverseProjection, float4(coord, 0, 1));
    ray.Direction = normalize(mul(_cameraToWorld, float4(ray.Direction, 0)).xyz);
    ray.TMin = 0;
    ray.TMax = T_MAX;
    return ray;
}

[shader("raygeneration")]
void GenerateRays()
{
    uint2 id = DispatchRaysIndex().xy;
    uint2 dim = DispatchRaysDimensions().xy;
    RayDesc ray = NewCameraRay(id, dim);
    RayPayload payload = NewPayload(id.x * dim.x + id.y);
    float4 accumulate = payload.color;
    for (int i = 0; i < SAMPLE_COUNT; ++i, payload = NewPayload(payload.seed))
    {
        TraceRay(_DiffuseBVH, RAY_FLAG, INSTANCE_INCLUSION_MASK, RAY_CONTRIB_HITGROUP_IDX, GEOMETRY_STRIDE, MISS_SHADER, ray, payload);
        accumulate += payload.color;
    }
  
    RenderTarget[id] = accumulate / SAMPLE_COUNT;
}

[shader("miss")]
void SampleSkybox(inout RayPayload payload : SV_RayPayload)
{
    float3 dir = WorldRayDirection();
    float theta = acos(dir.y) / -PI;
    float phi = atan2(dir.x, -dir.z) * -INV_PI * 0.5f; // -1/2pi
    float4 skyboxColor = _skybox.SampleLevel(sampler_skybox, float2(phi, theta), 0) * sin(PI * 0.5f * dir.y);
    payload.color = skyboxColor;
    payload.depth = 0;
}
