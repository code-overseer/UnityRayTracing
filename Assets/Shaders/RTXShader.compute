// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
static const float PI = 3.14159265359f;
static const float EPSILON = 1e-5f;
static const int MAX_DEPTH = 4;
static const int SIZE = 8;
static const float IOR = 1.6f;

struct Ray 
{
    float3 origin;
    float3 direction;
};

struct Plane 
{
    float3 origin;
    float3 normal;
    float3 color;
};

struct Sphere 
{
    float3 centre;
    float3 color;
    float radius;
};

struct RayHit
{
    float3 pos;
    float3 normal;
    float3 color;
    float distance;
};

struct State 
{
    RayHit hit;
    Ray ray;
    int depth;
    float refl;
    bool outside;
};

float3 Black()
{
    return float3(0.0f, 0.0f, 0.0f);
}

float3 White() 
{
    return float3(1.0f, 1.0f, 1.0f);
}

Ray CreateRay(in float3 origin, in float3 direction) 
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    // Transform the camera origin to world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

RayHit CreateRayHit()
{
    RayHit hit;
    hit.pos = Black();
    hit.distance = 1.#INF;
    hit.normal = Black();
    hit.color = Black();
    return hit;
}

void PlaneHit(in Plane pl, in Ray ray, inout RayHit hit) 
{
    float t = dot(pl.origin - ray.origin, pl.normal) / dot(ray.direction, pl.normal);
	if (t < 0) return;
	float checker;
	const float freq = 4;
	
	if (t > hit.distance) return; 
	hit.distance = t;
    hit.pos = ray.origin + hit.distance * ray.direction;
    hit.normal = pl.normal;

    float x = hit.pos.x - pl.origin.x;
    float z = hit.pos.z - pl.origin.z;
    checker = (cos(x*freq)*cos(z*freq) > 0); 

    hit.color = pl.color * checker;	
}

void SphereHit(in Sphere sph, in Ray ray, inout RayHit hit)
{
	float3 centreToRayOrigin = ray.origin - sph.centre;

	// Quadratic eqn = at^2 + bt +c = 0
	float a = dot(ray.direction, ray.direction);
	float b = 2 * dot(ray.direction, centreToRayOrigin);
	float c = dot(centreToRayOrigin, centreToRayOrigin) - sph.radius * sph.radius;

	// discriminant
	float discrim = b * b - 4 * a * c;

	if (discrim < 0) return;

	// Root of quadratic eqn
	float t = (-b - sqrt(discrim))/(2*a);
	if (t < 0) {
		t = (-b + sqrt(discrim))/(2*a);
		if (t < 0) return;
	}

	if (t < hit.distance) {
		hit.distance = t;
		hit.pos = ray.origin + hit.distance * ray.direction;
		hit.normal = normalize(hit.pos - sph.centre);
		hit.color = sph.color;
	}
	
}

static const Plane ground = { float3(0.0f, -1.0f, 0.0f), float3(0.0f, 1.0f, 0.0f), White() };
static const int N = 3;
static Sphere spheres[N];

bool FindHit(inout State state)
{    
	PlaneHit(ground, state.ray, state.hit);	
	for (int i = 0; i < N; ++i) 
	{
	    SphereHit(spheres[i], state.ray, state.hit);
	}
	state.outside = dot(state.ray.direction, state.hit.normal) < 0;
	
	return state.hit.distance < 100000.0f;
}

bool FindHit(in Ray ray, in RayHit hit)
{
    PlaneHit(ground, ray, hit);	
	for (int i = 0; i < N; ++i) 
	{
	    SphereHit(spheres[i], ray, hit);
	}
	
	return hit.distance < 100000.0f;
}

static const float3 SOURCE = float3(3.0f, 6.0f, 5.0f);
static const float3 AMBIENT = float3(0.9f, 0.8f, 0.7f);
static const float KS = 0.1f;

void Shadow(inout State state) 
{
    Ray ray = CreateRay(state.hit.pos, normalize(SOURCE - state.hit.pos));
    ray.origin += (state.outside ? EPSILON : -EPSILON) * state.hit.normal;
    if ( !state.outside || dot(state.hit.normal, ray.direction) < 0 
        || !FindHit(ray, CreateRayHit()) ) return;
     
    state.hit.color *= KS;
}

void Shade(inout State state) 
{   
    float3 n = (state.outside - !state.outside) * state.hit.normal;
	float3 l = normalize(SOURCE - state.hit.pos);
	float3 h = normalize(l - state.ray.direction);
	float d = length(SOURCE - state.hit.pos);
	
	const float shininess = 60;
	const float intensity = 800;
	
    float3 outColour = max(dot(n, l), 0.0f) * state.hit.color;
	outColour += pow(max(dot(n, h), 0.0f), shininess) * AMBIENT;
	outColour *= intensity / (1 + 4 * PI * d * d);
	outColour += KS * state.hit.color;
    state.hit.color = outColour;
    
    //Shadow(state);
}

void Refract(inout State state) 
{ 
	float cosi = dot(state.ray.direction, state.hit.normal);
	float3 n = state.outside ? state.hit.normal : -state.hit.normal; 
	float eta = pow(IOR, !state.outside - state.outside);
	float k = 1.0f - eta * eta * (1 - cosi * cosi);
	state.ray.direction = (k < 0) ? Black() : normalize(eta * state.ray.direction + (eta * abs(cosi) - sqrt(k)) * n);
	state.ray.origin = state.hit.pos;
	state.ray.origin += (state.outside ? -EPSILON : EPSILON) * state.hit.normal;
}

void Reflect(inout State state) 
{
    state.ray.direction = normalize(reflect(state.ray.direction, state.hit.normal));
    state.ray.origin = state.hit.pos;
    state.ray.origin += (state.outside ? EPSILON : -EPSILON) * state.hit.normal;
}

bool Fresnel(inout State state) 
{
	float cosi = dot(state.ray.direction, state.hit.normal);
	bool b = (cosi > 0);
	float etai = b * IOR + !b;
	float etat = b + !b * IOR;
	
	cosi = abs(cosi);
	float r0 = (etai - etat)/(etai + etat);
	r0 *= r0;
	float k = r0 + (1 - r0) * pow((1 - cosi), 5);
	b = k < 1;
	
	state.refl = !b + b * k;

	return state.refl < 1;
}

static State states[SIZE];
State Init(in float2 uv) 
{
    State state;
    state.ray = CreateCameraRay(uv);
    state.hit = CreateRayHit();
    state.outside = true;
    state.refl = 1;
    state.depth = 0;

    spheres[0].centre   = float3(0.0f, 0.0f, 1.0f);;
	spheres[0].radius   = 0.5f;
	spheres[0].color = Black();
    spheres[1].centre   = float3(2.5f, 0.0f, 1.0f);
	spheres[1].radius   = 0.25f;
	spheres[1].color = float3(0.3f,0.7f,0.2f);
	spheres[2].centre   = float3(-2.0f, 0.0f, -1.0f);
	spheres[2].radius   = 0.7f;
	spheres[2].color = float3(0.9f,0.2f,0.2f);
    
    return state;
}

void Push(inout int ptr, in State current) 
{
    if (ptr >= SIZE || current.depth >= MAX_DEPTH) return;
   
    states[ptr++] = current;
}

void Pop(inout int ptr, out State current) 
{
    current = states[--ptr];
}

void Trace(inout int ptr, inout float3 color, inout State current) {
    if (current.depth >= MAX_DEPTH) return;
    current.hit.distance = 100000.0f;
    if (!FindHit(current)) 
    {
        if (ptr > 0) 
        {
            Pop(ptr, current);
            color += current.hit.color * current.refl;
            Reflect(current);
        }
        ++current.depth;
        return;
    } 
    Shade(current);
    if (Fresnel(current)) 
    {
        Push(ptr, current);
        color += current.hit.color * (1 - current.refl);
        Refract(current);
    } 
    else 
    {
        color += current.hit.color * current.refl;
        Reflect(current);
    }
    ++current.depth;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    /* ----Boilerplate---- */
    uint width, height;
    Result.GetDimensions(width, height);
    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);
    State current = Init(uv);
    float3 color = Black();
    int stack_ptr = 0;
    /* ----Boilerplate---- */
    //if (FindHit(current)) Shade(current);
    //color += current.hit.color;
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    
    Trace(stack_ptr, color, current);
    
    Result[id.xy] = float4(color, 1);
}