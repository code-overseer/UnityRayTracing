// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#include "shader.cginc"

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
Texture2D<float4> _skybox;
SamplerState sampler_skybox;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
static const int MAX_DEPTH = 4;
static const float IOR = 2.1f;
static Plane ground;
static const int N = 4;
static Sphere spheres[N];
static Box box;
static Point source;
static State states[MAX_DEPTH - 1];

bool FindHit(inout State state)
{    
	if (PlaneHit(ground, state.ray, state.hit))
	{
	    float2 v = 4 * (state.hit.pos.xz - ground.pos.xz);
	    state.hit.mat.rho = ground.mat.rho * (cos(v.x)*cos(v.y) > 0);
	}
	
	for (int i = 0; i < N; ++i) 
	{
	    SphereHit(spheres[i], state.ray, state.hit);
	}
	BoxHit(box, state.ray, state.hit);
	state.kr_d_out.z = dot(state.ray.dir, state.hit.n) < 0;
	
	return state.hit.dist_type[0] < MAX_DIST;
}

void Refract(inout State state) 
{ 
	float cosi = dot(state.ray.dir, state.hit.n);
	float3 n = state.kr_d_out.z ? state.hit.n : -state.hit.n; 
	float eta = pow(IOR, !state.kr_d_out.z - state.kr_d_out.z);
	float k = 1.0f - eta * eta * (1 - cosi * cosi);
	state.ray.dir = (k < 0) ? Black() : normalize(eta * state.ray.dir + (eta * abs(cosi) - sqrt(k)) * n);
	state.ray.origin = state.hit.pos;
	state.ray.origin += (state.kr_d_out.z ? -EPSILON : EPSILON) * state.hit.n;
}

void Reflect(inout State state) 
{
    state.ray.dir = normalize(reflect(state.ray.dir, state.hit.n));
    state.ray.origin = state.hit.pos;
    state.ray.origin += (state.kr_d_out.z ? EPSILON : -EPSILON) * state.hit.n;
}

bool Fresnel(inout State state) 
{
	float cosi = dot(state.ray.dir, state.hit.n);
	bool b = (cosi > 0);
	float etai = b * IOR + !b;
	float etat = b + !b * IOR;
	float r0 = pow((etai - etat)/(etai + etat), 2);
	float k = r0 + (1 - r0) * pow((1 - abs(cosi)), 5);
	b = k < 1;
	state.kr_d_out.x = !b + b * k;
	return state.kr_d_out.x < 1;
}

void Shadow(inout State state) 
{
    State shadow;
    shadow.kr_d_out[1] = 0;
    shadow.kr_d_out[0] = 1;
    
    shadow.ray = CreateRay(state.hit.pos, normalize(source.pos - state.hit.pos));
    shadow.ray.origin += (state.kr_d_out.z ? EPSILON : -EPSILON) * state.hit.n;
    shadow.hit = CreateRayHit();
    state.hit.mat.rho *= state.kr_d_out.z + !state.kr_d_out.z * (1 - state.kr_d_out[0]);
    if ( !state.kr_d_out.z || dot(state.hit.n, shadow.ray.dir) < 0 || !FindHit(shadow) ) return;
    
    state.hit.mat.rho *= max(KS, (shadow.hit.dist_type[1] == TRANS) * abs(dot(shadow.ray.dir, shadow.hit.n)));
}

void Shade(inout State state) 
{   
    float3 n = (state.kr_d_out.z - !state.kr_d_out.z) * state.hit.n;
	float3 l = normalize(source.pos - state.hit.pos);
	float3 h = normalize(l - state.ray.dir);
	float d = length(source.pos - state.hit.pos);
	
	const float shininess = 60;
	const float intensity = 800;
	
    float3 outColour = max(dot(n, l), 0.0f) * state.hit.mat.rho;
	outColour += pow(max(dot(n, h), 0.0f), shininess) * source.mat.eps;
	outColour *= intensity / (1 + 4 * PI * d * d);
	outColour += KS * state.hit.mat.rho;
    state.hit.mat.rho = outColour;
    
    Shadow(state);
}

State Init(in float2 uv) 
{
    State state;
    state.ray = CreateCameraRay(_CameraToWorld, _CameraInverseProjection, uv);
    state.hit = CreateRayHit();
    state.kr_d_out.x = 1;
    state.kr_d_out.y = 0;
    state.kr_d_out.z = 1;
    
    source.pos = float3(3.0f, 6.0f, 5.0f);
    source.mat = CreateMaterial(Black(), float3(0.9f, 0.8f, 0.7f), 1);
    
    ground.pos = float3(0, -1, 0);
    ground.n = float3(0, 1, 0);
    ground.mat = CreateMaterial(White()*0.4f, Black(), 1);
    ground.type = DIFF;

    spheres[0].centre   = float4(0.3f, -0.45f, 0.6f, 0.5f);
	spheres[0].mat = CreateMaterial(Black(), Black(), 1);
	spheres[0].type = TRANS;
    spheres[1].centre   = float4(0.7f, -0.6f, -1.0f, 0.25f);
	spheres[1].mat = CreateMaterial(float3(0.3f,0.7f,0.2f), Black(), 1);
	spheres[1].type = REFL;
	spheres[2].centre   = float4(-1.0f, -0.5f, 0.5f, 0.4f);
	spheres[2].mat = CreateMaterial(float3(0.9f,0.2f,0.2f), Black(), 1);
	spheres[2].type = REFL;
	spheres[3].centre   = float4(0.0f, -0.4f, -0.5f, 0.3f);
	spheres[3].mat = CreateMaterial(float3(0.8f,0.2f,0.9f), Black(), 1);
	spheres[3].type = DIFF;
	
	box.pn[0] = float4(-0.8f,-0.4f,-0.8f,1);
	box.pn[1] = float4(normalize(float3(0,-0.3f,4)),0.25f);
	box.pn[2] = float4(normalize(float3(-2.46,1.2,0.09)),0.25f);
	box.pn[3] = float4(normalize(cross(box.pn[1].xyz, box.pn[2].xyz)),0.25f);
	box.mat = CreateMaterial(float3(0.1f,0.2f,0.9f), Black(),1);
	box.type = TRANS;
    
    return state;
}

void Push(inout int ptr, in State current) 
{
    if (ptr >= MAX_DEPTH - 1) return;
    states[ptr++] = current;
}

void Pop(inout int ptr, out State current) 
{
    current = states[--ptr];
}

void Trace(inout int ptr, inout float3 color, inout State current) 
{
    current.hit.dist_type[0] = MAX_DIST;
    
    if (current.kr_d_out[1] >= MAX_DEPTH || !FindHit(current)) 
    {
        if (!(current.hit.dist_type[0] < MAX_DIST)) 
        {
            float theta = acos(current.ray.dir.y) / -PI;
            float phi = atan2(current.ray.dir.x, -current.ray.dir.z) / -PI * 0.5f;
            color += _skybox.SampleLevel(sampler_skybox, float2(phi, theta), 0).xyz * KS * sin(PI * 0.5f * current.ray.dir.y);
        }
        if (ptr > 0) 
        {
            Pop(ptr, current);
            color += current.hit.mat.rho * current.kr_d_out[0];
            Reflect(current);
        }
        ++current.kr_d_out[1];
        return;
    } 
    Shade(current);
    if (current.hit.dist_type[1] == TRANS && Fresnel(current)) 
    {
        Push(ptr, current);
        color += current.hit.mat.rho * (1 - current.kr_d_out[0]);
        Refract(current);
    } 
    else if (current.hit.dist_type[1] != DIFF)
    {
        color += current.hit.mat.rho;
        Reflect(current);
    } 
    else 
    {
        color += current.hit.mat.rho;
        current.kr_d_out[1] = MAX_DEPTH;
    }
    ++current.kr_d_out[1];
}

float2 _pixelOffset;
[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    /* ----Boilerplate---- */
    uint width, height;
    Result.GetDimensions(width, height);
    float2 uv = float2((id.xy + _pixelOffset) / float2(width, height) * 2.0f - 1.0f);
    State current = Init(uv);
    
    float3 color = Black();
    int stack_ptr = 0;
    /* ----Boilerplate---- */
    //if (FindHit(current)) 
    //{
        //Shade(current);
        //color += current.hit.mat.rho;
    //}
    int nodes = pow(2, MAX_DEPTH);
    for (int i = 0; i < nodes; ++i) 
    {
        Trace(stack_ptr, color, current);
    }
    
    
    Result[id.xy] = float4(color, 1);
}