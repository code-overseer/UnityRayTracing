// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
Texture2D<float4> _skybox;
SamplerState sampler_skybox;

float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
static const float PI = 3.14159265359f;
static const float EPSILON = 1e-5f;
static const int MAX_DEPTH = 4;
static const float IOR = 1.6f;

struct Ray 
{
    float3 origin;
    float3 direction;
};

struct Plane 
{
    float3x3 pnc;
};

struct Sphere 
{
    float4 centre;
    float3 color;
};

struct RayHit
{
    float3x3 pnc;
    float distance;
};

struct State 
{
    RayHit hit;
    Ray ray;
    int depth;
    float refl;
    bool outside;
};

float3 Black()
{
    return float3(0.0f, 0.0f, 0.0f);
}

float3 White() 
{
    return float3(1.0f, 1.0f, 1.0f);
}

Ray CreateRay(in float3 origin, in float3 direction) 
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    // Transform the camera origin to world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

RayHit CreateRayHit()
{
    RayHit hit;
    hit.distance = 1.#INF;
    hit.pnc[0] = Black();
    hit.pnc[1] = Black();
    hit.pnc[2] = Black();
    return hit;
}

void PlaneHit(in Plane pl, in Ray ray, inout RayHit hit) 
{
    float t = dot(pl.pnc[0] - ray.origin, pl.pnc[1]) / dot(ray.direction, pl.pnc[1]);
	if (t < 0 || t > hit.distance) return;
	hit.distance = t;
    hit.pnc[0] = ray.origin + hit.distance * ray.direction;
    hit.pnc[1] = pl.pnc[1];

    float2 v = 4 * (hit.pnc[0].xz - pl.pnc[0].xz);
    

    hit.pnc[2] = pl.pnc[2] * (cos(v.x)*cos(v.y) > 0);	
}

void SphereHit(in Sphere sph, in Ray ray, inout RayHit hit)
{
	float3 centreToRayOrigin = ray.origin - sph.centre.xyz;

	// Quadratic eqn = at^2 + bt +c = 0
	float a = dot(ray.direction, ray.direction);
	float b = 2 * dot(ray.direction, centreToRayOrigin);
	float c = dot(centreToRayOrigin, centreToRayOrigin) - sph.centre.w * sph.centre.w;

	// discriminant
	float d = b * b - 4 * a * c;
	if (d < 0) return;

	// Root of quadratic eqn
	float t = (-b - sqrt(d))/(2*a);
	if (t < 0) {
		t = (-b + sqrt(d))/(2*a);
		if (t < 0) return;
	}

	if (t < hit.distance) {
		hit.distance = t;
		hit.pnc[0] = ray.origin + hit.distance * ray.direction;
		hit.pnc[1] = normalize(hit.pnc[0] - sph.centre.xyz);
		hit.pnc[2] = sph.color;
	}
	
}

static const Plane ground = { float3(0.0f, -1.0f, 0.0f), float3(0.0f, 1.0f, 0.0f), White() };
static const int N = 3;
static Sphere spheres[N];

bool FindHit(inout State state)
{    
	PlaneHit(ground, state.ray, state.hit);	
	for (int i = 0; i < N; ++i) 
	{
	    SphereHit(spheres[i], state.ray, state.hit);
	}
	state.outside = dot(state.ray.direction, state.hit.pnc[1]) < 0;
	
	return state.hit.distance < 100000.0f;
}

bool FindHit(in Ray ray, in RayHit hit)
{
    PlaneHit(ground, ray, hit);	
	for (int i = 0; i < N; ++i) 
	{
	    SphereHit(spheres[i], ray, hit);
	}
	
	return hit.distance < 100000.0f;
}

static const float3 SOURCE = float3(3.0f, 6.0f, 5.0f);
static const float3 AMBIENT = float3(0.9f, 0.8f, 0.7f);
static const float KS = 0.1f;

void Shadow(inout State state) 
{
    Ray ray = CreateRay(state.hit.pnc[0], normalize(SOURCE - state.hit.pnc[0]));
    ray.origin += (state.outside ? EPSILON : -EPSILON) * state.hit.pnc[1];
    if ( !state.outside || dot(state.hit.pnc[1], ray.direction) < 0 
        || !FindHit(ray, CreateRayHit()) ) return;
     
    state.hit.pnc[2] *= KS;
}

void Shade(inout State state) 
{   
    float3 n = (state.outside - !state.outside) * state.hit.pnc[1];
	float3 l = normalize(SOURCE - state.hit.pnc[0]);
	float3 h = normalize(l - state.ray.direction);
	float d = length(SOURCE - state.hit.pnc[0]);
	
	const float shininess = 60;
	const float intensity = 800;
	
    float3 outColour = max(dot(n, l), 0.0f) * state.hit.pnc[2];
	outColour += pow(max(dot(n, h), 0.0f), shininess) * AMBIENT;
	outColour *= intensity / (1 + 4 * PI * d * d);
	outColour += KS * state.hit.pnc[2];
    state.hit.pnc[2] = outColour;
    
    Shadow(state);
}

void Refract(inout State state) 
{ 
	float cosi = dot(state.ray.direction, state.hit.pnc[1]);
	float3 n = state.outside ? state.hit.pnc[1] : -state.hit.pnc[1]; 
	float eta = pow(IOR, !state.outside - state.outside);
	float k = 1.0f - eta * eta * (1 - cosi * cosi);
	state.ray.direction = (k < 0) ? Black() : normalize(eta * state.ray.direction + (eta * abs(cosi) - sqrt(k)) * n);
	state.ray.origin = state.hit.pnc[0];
	state.ray.origin += (state.outside ? -EPSILON : EPSILON) * state.hit.pnc[1];
}

void Reflect(inout State state) 
{
    state.ray.direction = normalize(reflect(state.ray.direction, state.hit.pnc[1]));
    state.ray.origin = state.hit.pnc[0];
    state.ray.origin += (state.outside ? EPSILON : -EPSILON) * state.hit.pnc[1];
}

bool Fresnel(inout State state) 
{
	float cosi = dot(state.ray.direction, state.hit.pnc[1]);
	bool b = (cosi > 0);
	float etai = b * IOR + !b;
	float etat = b + !b * IOR;
	
	cosi = abs(cosi);
	float r0 = (etai - etat)/(etai + etat);
	r0 *= r0;
	float k = r0 + (1 - r0) * pow((1 - cosi), 5);
	b = k < 1;
	
	state.refl = !b + b * k;

	return state.refl < 1;
}

static State states[MAX_DEPTH - 1];
State Init(in float2 uv) 
{
    State state;
    state.ray = CreateCameraRay(uv);
    state.hit = CreateRayHit();
    state.outside = true;
    state.refl = 1;
    state.depth = 0;

    spheres[0].centre   = float4(0.0f, 0.0f, 1.0f, 0.5f);
	spheres[0].color = Black();
    spheres[1].centre   = float4(2.5f, 0.0f, 1.0f, 0.25f);
	spheres[1].color = float3(0.3f,0.7f,0.2f);
	spheres[2].centre   = float4(-2.0f, 0.0f, -1.0f, 0.7f);
	spheres[2].color = float3(0.9f,0.2f,0.2f);
    
    return state;
}

void Push(inout int ptr, in State current) 
{
    if (ptr >= MAX_DEPTH - 1) return;
    states[ptr++] = current;
}

void Pop(inout int ptr, out State current) 
{
    current = states[--ptr];
}

void Trace(inout int ptr, inout float3 color, inout State current) {
    current.hit.distance = 100000.0f;
    
    if (current.depth >= MAX_DEPTH || !FindHit(current)) 
    {
        if (!(current.hit.distance < 100000.0f)) 
        {
            float theta = acos(current.ray.direction.y) / -PI;
            float phi = atan2(current.ray.direction.x, -current.ray.direction.z) / -PI * 0.5f;
            color += _skybox.SampleLevel(sampler_skybox, float2(phi, theta), 0).xyz * KS;
        }
        if (ptr > 0) 
        {
            Pop(ptr, current);
            color += current.hit.pnc[2] * current.refl;
            Reflect(current);
        }
        ++current.depth;
        return;
    } 
    Shade(current);
    if (Fresnel(current)) 
    {
        Push(ptr, current);
        color += current.hit.pnc[2] * (1 - current.refl);
        Refract(current);
    } 
    else 
    {
        color += current.hit.pnc[2] * current.refl;
        Reflect(current);
    }
    ++current.depth;
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    /* ----Boilerplate---- */
    uint width, height;
    Result.GetDimensions(width, height);
    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);
    State current = Init(uv);
    float3 color = Black();
    int stack_ptr = 0;
    /* ----Boilerplate---- */
    //if (FindHit(current)) Shade(current);
    //color += current.hit.pnc[2];
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    Trace(stack_ptr, color, current);
    
    Trace(stack_ptr, color, current);
    
    Result[id.xy] = float4(color, 1);
}