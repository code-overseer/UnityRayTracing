// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWTexture2D<float4> Result;
float4x4 _CameraToWorld;
float4x4 _CameraInverseProjection;
static const float PI = 3.14159265359f;
static const float EPSILON = 1e-5f;
static const int MAX_DEPTH = 6;

struct Ray 
{
    float3 origin;
    float3 direction;
};

struct Plane 
{
    float3 origin;
    float3 normal;
    float3 color;
};

struct Sphere 
{
    float3 centre;
    float radius;
    float3 color;
};

struct RayHit
{
    float3 pos;
    float distance;
    float3 normal;
    float3 color;
};

float3 Black()
{
    return float3(0.0f, 0.0f, 0.0f);
}

float3 White() 
{
    return float3(1.0f, 1.0f, 1.0f);
}

Ray CreateRay(in float3 origin, in float3 direction) 
{
    Ray ray;
    ray.origin = origin;
    ray.direction = direction;
    return ray;
}

Ray CreateCameraRay(float2 uv)
{
    // Transform the camera origin to world space
    float3 origin = mul(_CameraToWorld, float4(0.0f, 0.0f, 0.0f, 1.0f)).xyz;
    
    // Invert the perspective projection of the view-space position
    float3 direction = mul(_CameraInverseProjection, float4(uv, 0.0f, 1.0f)).xyz;
    // Transform the direction from camera to world space and normalize
    direction = mul(_CameraToWorld, float4(direction, 0.0f)).xyz;
    direction = normalize(direction);

    return CreateRay(origin, direction);
}

RayHit CreateRayHit()
{
    RayHit hit;
    hit.pos = Black();
    hit.distance = 1.#INF;
    hit.normal = Black();
    hit.color = Black();
    return hit;
}

void PlaneHit(in Plane pl, in Ray ray, inout RayHit hit) {
    float t = dot(pl.origin - ray.origin, pl.normal) / dot(ray.direction, pl.normal);
	if (t < 0) return;
	float checker;
	const float freq = 4;
	
	if (t < hit.distance) {
		hit.distance = t;
		hit.pos = ray.origin + hit.distance * ray.direction;
		hit.normal = pl.normal;
		hit.pos += EPSILON * hit.normal;

		float x = hit.pos.x - pl.origin.x;
		float z = hit.pos.z - pl.origin.z;
		checker = (cos(x*freq)*cos(z*freq) > 0); 

		hit.color = pl.color * checker;
	}	
}
void SphereHit(in Sphere sph, in Ray ray, inout RayHit hit)
{
	float3 centreToRayOrigin = ray.origin - sph.centre;

	// Quadratic eqn = at^2 + bt +c = 0
	float a = dot(ray.direction, ray.direction);
	float b = 2 * dot(ray.direction, centreToRayOrigin);
	float c = dot(centreToRayOrigin, centreToRayOrigin) - sph.radius * sph.radius;

	// discriminant
	float discrim = b * b - 4 * a * c;

	if (discrim < 0) {
		return;
	}

	// Root of quadratic eqn
	float t = (-b - sqrt(discrim))/(2*a);
	if (t < 0) {
		t = (-b + sqrt(discrim))/(2*a);
		if (t < 0) { return; }
	}

	if (t < hit.distance) {
		hit.distance = t;
		hit.pos = ray.origin + hit.distance * ray.direction;
		hit.normal = normalize(hit.pos - sph.centre);
		hit.pos += EPSILON * hit.normal;
		hit.color = sph.color;
	}
	return;
	
}

void FindHit(in Ray r, inout RayHit i)
{
    Plane ground;
    ground.origin = float3(0.0f, -1.0f, 0.0f);
    ground.normal = float3(0.0f, 1.0f, 0.0f);
    ground.color = White();
     
    Sphere sphere;
    sphere.centre   = float3(0.0f, 0.0f, 1.0f);
	sphere.radius   = 0.5f;
	sphere.color = float3(0.2f,0.8f,0.3f);
     
	PlaneHit(ground, r, i);	
	SphereHit(sphere, r, i);
}

static float3 SOURCE = float3(3.0f, 6.0f, -5.0f);
static float3 AMBIENT = float3(0.9f, 0.8f, 0.7f);
void Shade(inout RayHit hit, in Ray ray) 
{   
	float3 l = normalize(SOURCE - hit.pos);
    RayHit shadow = CreateRayHit();
    FindHit(CreateRay(hit.pos, l), shadow);
    if (shadow.distance < 1e+5f) {
        hit.color *= 0.1f;
        return;
    }
	float3 h = normalize(l - ray.direction);
	float d = length(SOURCE - hit.pos);
	
	const float shininess = 60;
	const float intensity = 750;
	
    float3 outColour = max(dot(hit.normal, l), 0.0f) * hit.color;
	outColour += pow(max(dot(hit.normal, h), 0.0f), shininess) * AMBIENT;
	outColour *= intensity / (1 + 4 * PI * d * d);
	outColour += 0.1f * hit.color;
    
    hit.color = outColour; 
}

[numthreads(8,8,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{

    /* ----Boilerplate---- */
    uint width, height;
    Result.GetDimensions(width, height);
    // Transform pixel to [-1,1] range
    float2 uv = float2((id.xy + float2(0.5f, 0.5f)) / float2(width, height) * 2.0f - 1.0f);
    // Get a ray for the UVs
    Ray ray = CreateCameraRay(uv);
    RayHit hit = CreateRayHit();
    float3 color = Black();
    /* ----Boilerplate---- */
    
    
    for (int d = 0; d < 1; ++d) 
    {
        hit.distance = 100000.0f;
        FindHit(ray, hit);
        if (hit.distance >= 100000.0f) {
            Result[id.xy] = float4(Black(), 1);
            return;
        }
        Shade(hit, ray);
        color += hit.color;
        //ray.direction = normalize(reflect(ray.direction, hit.normal)); 
        //ray.origin = hit.pos + EPSILON*hit.normal;
    }
    
    Result[id.xy] = float4(color, 1);
}